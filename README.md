# LIN-Bus-Attiny13
Connect your LIN to attiny and play wthis data

# Простой считыватель данных с LIN шины, работает на таймере и прерываниях.

```c++
#define start_count  14               //начало отсчета битов с середины после спадающего фронта

volatile uint8_t point = 0;           //указатель на бит при чтение ЛИН
volatile uint8_t brk = 0;             //определение break 14 бит LIN
volatile uint8_t data = 0;            //считаный байт ЛИН
volatile uint16_t timeOut = 0;        //время определения конца передачи пакета
volatile uint8_t LIN[11];             //пакет ЛИН
volatile uint8_t LINcount = 0;        //указатель на байт в пакете при чтение


void setup()
{
  cli();

  GIMSK |= (1 << INT0);              //разрешить внешние прерыванияЛИН
  MCUCR |= (1 << ISC00);             //конфигурация прерывания на изменение любого состояния

  TCCR0A |= (1 << WGM01);            //конфигурация таймера режим СТС
  TIMSK0 = (1 << OCIE0A);            //уставновка вектора прерывания таймера
  sei();
}


ISR(INT0_vect) {
  TCNT0 = 0;    OCR0A = start_count;    timeOut = 0;
  if (PINB & (1 << PB1)) {                                    //если во время прерывания логическая 1
    if (point > 12 && brk == 0) {                             //определение break ЛИН, установка флага что break обнаружен
      TCCR0B &= ~(1 << CS01);                                 //остановка таймера для ожтдания стартового бита для чтения пакетов ЛИН
      brk = 1;   point = 0;   data = 0;   LINcount = 0;       //все переменные в стартовое положение
    }
  }
  else if (!(PINB & (1 << PB1))) {                            //если во время прерывания логическая 0
    TCCR0B |= (1 << CS01);
  }
}


ISR(TIM0_COMPA_vect) {                                                                    
    TCNT0 = 0;                                                                          //счетчик в 0
    OCR0A = 60;                                                                         //переопределение счета каждого бита
    point += 1;                                                                         //инкремент указателя на каком бите сейчас находимся

 if (brk == 1 && point > 1 && point < 10) {                    //определения первого бита полезных данных
    if ((PINB & (1 << PB1)))data = data | (1 << (point - 2));   //чтение бита и установка его в переменную data со смещением по егоправильному положению
    if ((point - 2) == 7) {                                     //определения последнего бита
      TCCR0B &= ~(1 << CS01);                                   //отключения таймера для ожидания стартового бита для чтения
      LIN[LINcount] = data;                                     //установка байта данных в массив пакета по очередности
      LINcount++;                                               //определения последнего бита
      point = 0;
      data = 0;
    }
  }
}


void loop()
{
  if (PINB & (1 << PB1) && point == 0 || point == 1) {                          //инкремент переменной если на пине логическая 1 для определения конца пакета
    timeOut++;
  }
  if (timeOut > 500 && pic == 0) {                                             //при переполнение тайм аута произвести рачсет данных для определения действия
    TCCR0B &= ~(1 << CS01);
    \*
      Поместите сюда свой код для определения байтов данных
      LIN[0] - байт синхронизации 0x55
      LIN[1] - PID(Protected ID) защищенный байт идинтификатора, для определения чистого ID устройства нужно применить маску LIN[1] & 0x3F
      LIN[2]...LIN[n] - байты данных
    *\
    LINcount = 0;
    brk = 0;
    timeOut = 0;
  }
}

```
# Частота работы
Данный код считывает данные на скорости 19200, для изменения часто нужно изменить и подобрать тайминги таймера, но в большинстве LIN работает на 19200.

# Обработка и получения данных
Все байты данных получаются в условии:
```c++
if (timeOut > 500 && pic == 0) {                                             //при переполнение тайм аута произвести рачсет данных для определения действия
    TCCR0B &= ~(1 << CS01);
... ваш код
```
Это обусловлено тем что данное условие срабатывает после прочтения всех байт и выхода по таймауту длительность таймаута до 2ms на практике этого достаточно, а если нет то нужно изменить timeOut > 500.
Данные считываются до самого конца сколько бы их там не было, все ограничивается длиной массива LIN, но как правило это 1 байт синхронизации, 1 байт ИД, максимум 8 байт данные и 1 байт сумма.
После прочтения всех данных и определение нового сигнала break массив LIN очищается.
